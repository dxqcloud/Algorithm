# 最短路径算法

## 1. Dijkstra算法：单源最短路径算法，不能处理负边权。
* (1) 算法思想：
    设G=(V,E)是一个带权有向图，把图中顶点集合V分成两组，第一组为已求出最短路径的顶点集合（用S表示，初始时S中只有一个源点，以后每求得一条最短路径 , 就将加入到集合S中，直到全部顶点都加入到S中，算法就结束了），第二组为其余未确定最短路径的顶点集合（用U表示），按最短路径长度的递增次序依次把第二组的顶点加入S中。在加入的过程中，总保持从源点v到S中各顶点的最短路径长度不大于从源点v到U中任何顶点的最短路径长度。此外，每个顶点对应一个距离，S中的顶点的距离就是从v到此顶点的最短路径长度，U中的顶点的距离，是从v到此顶点只包括S中的顶点为中间顶点的当前最短路径长度。

* (2) 算法步骤：

  a.初始时，S只包含源点，即S＝{v}，v的距离为0。U包含除v外的其他顶点，即:U={其余顶点}，若v与U中顶点u   有边，则<u,v>正常有权值，若u不是v的出边邻接点，则<u,v>权值为∞。

  b.从U中选取一个距离v最小的顶点k，把k，加入S中（该选定的距离就是v到k的最短路径长度）。

  c.以k为新考虑的中间点，修改U中各顶点的距离；若从源点v到顶点u的距离（经过顶点k）比原来距离（不经过顶点	k）短，则修改顶点u的距离值，修改后的距离值的顶点k的距离加上边上的权。

  d.重复步骤b和c直到所有顶点都包含在S中。

************

## 2. Bellman-Fords： 单源最短路径算法，可以处理负边权。
* 算法描述： 和Dijkstra算法类似，每次对所有的边的目的节点进行松弛，进行V-1次，就完成了距离的计算。

************

## 3. Floyd算法:全源最短路径算法

* 1)算法思想原理：
   Floyd算法是一个经典的动态规划算法。用通俗的语言来描述的话，首先我们的目标是寻找从点i到点j的最短路径。从动态规划的角度看问题，我们需要为这个目标重新做一个诠释（这个诠释正是动态规划最富创造力的精华所在）

    从任意节点i到任意节点j的最短路径不外乎2种可能，1是直接从i到j，2是从i经过若干个节点k到j。所以，我们假设Dis(i,j)为节点u到节点v的最短路径的距离，对于每一个节点k，我们检查`Dis(i,k) + Dis(k,j) < Dis(i,j)`是否成立，如果成立，证明从i到k再到j的路径比i直接到j的路径短，我们便设置`Dis(i,j) = Dis(i,k) + Dis(k,j)`，这样一来，当我们遍历完所有节点k，`Dis(i,j)`中记录的便是i到j的最短路径的距离。

* 2).算法描述：

	a.从任意一条单边路径开始。所有两点之间的距离是边的权，如果两点之间没有边相连，则权为无穷大。
	b.对于每一对顶点 u 和 v，看看是否存在一个顶点 w 使得从 u 到 w 再到 v 比己知的路径更短。如果是更新它。

